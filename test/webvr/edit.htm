<!DOCTYPE html>
<html lang="en">
<head>
<title>editXr</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link rel="shortcut icon" sizes="192x192" href="/canvas/paint/catapulto.png">
<link rel="apple-touch-icon" href="/canvas/paint/catapulto.png">
<style>body { color:#000;background-color:#aaa;margin:0px;overflow:hidden;font-family:Sans-serif; }</style>
<script src="/conet.js"></script>
<script src="/menu.js"></script>
</head>
<body>
<script type="importmap">
{
"imports": {
"three": "/three/r160/build/three.module.js",
"three/addons/": "/three/r160/examples/jsm/"
}
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { XrUtil } from '/util/gfx/XrUtil.js';
(function() {
  //---
  let container,camera,scene,renderer,
      controls,ph,raycaster,sceneh={},
      xrUtil=XrUtil,lsKey='editXr_0',sels=[],
      grid={},gridw=0.01,cursor0,cursor1,
      points=[],nearestPoint,
      matPoint0,matPoint1,matPointSel;
      
  init();
  animate();
  
  function init() {
    //---
    container = document.createElement( 'div' );
    document.body.appendChild( container );
    
    scene=new THREE.Scene();
    scene.background=new THREE.Color(0x333333);//0x222222
    
    camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.01,50);
    camera.position.set(0,1.6,2);
    scene.add(camera);
    
    controls=new OrbitControls(camera,container);
    controls.target.set(0,1.6,0);
    
    /*
    let ls=localStorage[lsKey];
    if (ls) {
      ls=JSON.parse(ls);
      if (ls.pt) controls.target.set(ls.pt.x,ls.pt.y,ls.pt.z);
      if (ls.pc) camera.position.set(ls.pc.x,ls.pc.y,ls.pc.z); 
    }
    */
    
    controls.update();
    
    const grid=new THREE.GridHelper(4,4,0x555555,0x111111);
    scene.add(grid);
    
    scene.add(new THREE.HemisphereLight(0x888877,0x777788,3));
    
    const light=new THREE.DirectionalLight(0xffffff,3);
    light.position.set(0,6,0);
    scene.add(light);
    
    //
    
    renderer = new THREE.WebGLRenderer( { antialias:true } );
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth,window.innerHeight );
    renderer.xr.enabled=true;
    container.appendChild(renderer.domElement);
    
    xrUtil.init({scene:scene,renderer:renderer,camera:camera,room:scene,sculpt:1//,vrPos:vrPos
      });
    xrUtil.initHud();
    xrUtil.hud.buttons=[
    {s:'Save',x:0.5,y:0.7,w:0.45,h:0.25,ondown:function() {
      //---
      let s=serialize();
      localStorage[lsKey]=s;
      xrUtil.log('Saved '+s.length+' bytes.');
      //...
    }
    },
    ];
    
    const version='v.0.189 ';//FOLDORUPDATEVERSION
    xrUtil.log('Edit '+version);
    
    //
    
    matPoint0  =new THREE.MeshPhongMaterial({flatShading:true,color:0x66aa66,transparent:true,opacity:0.7});
    matPoint1  =new THREE.MeshPhongMaterial({flatShading:true,color:0xaaaa66,transparent:true,opacity:0.7});
    matPointSel=new THREE.MeshPhongMaterial({flatShading:true,color:0xdddddd,transparent:true,opacity:0.7});
    let cmat=new THREE.MeshPhongMaterial({flatShading:true,color:0xaaaaaa,transparent:true,opacity:0.7});
    
    {let mesh=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.01,0.01),cmat);
    mesh.position.z=-0.05;
    xrUtil.ctrl0.add(cursor0=mesh);} //left
    
    {let mesh=new THREE.Mesh(new THREE.BoxGeometry(0.02,0.02,0.02),cmat);
    mesh.position.z=-0.05;
    xrUtil.ctrl1.add(cursor1=mesh);} //right
    
    raycaster=new THREE.Raycaster();
    
    function point(x,y,down) {
      //---
      let p2=new THREE.Vector2(2*x/window.innerWidth-1,-2*y/window.innerHeight+1);
      raycaster.setFromCamera(p2,camera);
      let a=raycaster.intersectObjects(scene.children);
      
      //onsole.log('mousedown '+a.length);
      let np=undefined,hudo=undefined;
      for (let co of a) {
        let o=co.object;
        if (o===grid) continue;
        if (o===xrUtil.hudMesh) {
          //onsole.log('hud');
          hudo=co;
          break;
        }
        //onsole.log(o+' '+points.indexOf(o));
        if (points.indexOf(o)!=-1) {
          np=o;//setNearestPoint(o);
          break;
        }
      }
      
      xrUtil.hudIntersects(hudo,down);
      
      if (down) {
        select(np);
      } else setNearestPoint(np);
      //...
    }
    //
    window.addEventListener('resize',onWindowResize);
    const canv=renderer.domElement;
    canv.addEventListener('mousemove',function(e) {
      //---
      point(e.clientX,e.clientY,false);
      //...
    }
    ,false);
    canv.addEventListener('mousedown',function(e) {
      //---
      point(e.clientX,e.clientY,true);
      //...
    }
    );
    canv.parentElement.addEventListener('mouseup',function(e) {
      //---
      point(e.clientX,e.clientY,false);
      //...
    }
    );
    
    
    //---menu
    
    xrUtil.menuXr.ms+=' '+version;
    Menu.init([{s:'&#9776;',noTri:true,fs:1.4,pw:0.05,sub:[
      Menu.mFullscreen
      ]} 
     ,xrUtil.menuXr  
     
     ,{s:'Json',ms:'import/export',doctrl:'Json data',mcfs:0.07,ta:true,jsonCheck:1,wrap:0,tacols:30,tarows:20
      ,setfunc:load,valuef:serialize}
     
     
     /*
    ,{s:'SaveView',ms:'later via xr menu',actionf:function() {
      //---
      let pt=controls.target,pc=camera.position;
      let cfg={
        pt:{x:Conet.f4(pt.x),y:Conet.f4(pt.y),z:Conet.f4(pt.z)},
        pc:{x:Conet.f4(pc.x),y:Conet.f4(pc.y),z:Conet.f4(pc.z)}
      };
      cfg=JSON.stringify(cfg);
      console.log(cfg);
      localStorage[lsKey]=cfg;
      //...
    }
     }
     */
     
      ]
      ,{listen:1});
    
    
    //pointMaterial=new THREE.MeshPhongMaterial({color:0x77dd77,flatShading:true,transparent:true,opacity:0.7});
    
    ph=new THREE.Vector3();
    
    let ls=localStorage[lsKey];
    if (ls) load(ls);
    else {
      let g=new THREE.BoxGeometry(0.01,0.01,0.01),
      mesh=new THREE.Mesh(g,matPoint0);
      mesh.position.set(0,1,0);
      scene.add(mesh);points.push(mesh);
    
      mesh=new THREE.Mesh(g,matPoint0);
      mesh.position.set(0.05,1.05,0.05);
      scene.add(mesh);points.push(mesh);
    
      mesh=new THREE.Mesh(g,matPoint0);
      mesh.position.set(0.1,1.05,0.05);
      scene.add(mesh);points.push(mesh);
    }
    //...
  }
  function onWindowResize() {
    //---
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
    //...
  }
  //
  function animate() {
    renderer.setAnimationLoop(render);
  }
  
  function load(v) {
    //---
    let h=JSON.parse(v);
    if (h.pt) controls.target.set(h.pt.x,h.pt.y,h.pt.z);
    if (h.pc) camera.position.set(h.pc.x,h.pc.y,h.pc.z);
    
    let g=new THREE.BoxGeometry(0.01,0.01,0.01);
    for (let p of h.points) {
      let mesh=new THREE.Mesh(g,matPoint0);
      mesh.position.set(p.x,p.y,p.z);
      scene.add(mesh);points.push(mesh);
    }
    
    sceneh=Conet.hcopy(h,undefined,undefined,{points:1});;
    controls.update();
    //onsole.log(v);
    //...
  }
  
  let wasSelecting=undefined;
  function render() {
    //---
    if (xrUtil.isSession) {
      let ctrl1=xrUtil.ctrl1;
    
      ph.setFromMatrixPosition(cursor1.matrixWorld);
    
      let np=undefined,nd=0.01;//Number.MAX_VALUE;
      for (let p of points) {
        let d=p.position.distanceToSquared(ph);
        if (d<nd) { nd=d;np=p; }
      }
      setNearestPoint(np);
      //if (np) { xrUtil.log('nd='+nd);console.log('nd='+nd); }
    
      if (np&&ctrl1.userData.isSelecting) {
        if (wasSelecting!==np) {
          wasSelecting=np;
          select(np);
        }
        if (np.userData.selected) np.position.copy(ph);
      } else wasSelecting=undefined;
      
      if ((!np)&&ctrl1.userData.isSelecting) {
        if (sels.length>0) select(undefined);
      }
    }
    
    xrUtil.renderHud();
    renderer.render(scene,camera);
    //...
  }
  
  function select(p) {
    //---
    if (p===undefined) {
      for (let p of sels) {
        p.userData.selected=0;
        p.material=matPoint0;
      }
      sels.length=0;
    } else {
      let i=sels.indexOf(p);
      if (i!=-1) {
        sels.splice(i,1);
        p.userData.selected=0;
        p.material=matPoint0;
      } else {
        sels.push(p);
        p.material=matPointSel;
        p.userData.selected=1;
      }
    }
    
    xrUtil.log('Selected:'+sels.length);
    //...
  }
  
  function serialize() {
    //---
    
    if (!xrUtil.isSession) {
      let pt=controls.target,pc=camera.position;
      sceneh.pt={x:Conet.f4(pt.x),y:Conet.f4(pt.y),z:Conet.f4(pt.z)};
      sceneh.pc={x:Conet.f4(pc.x),y:Conet.f4(pc.y),z:Conet.f4(pc.z)};
    }
    
    let s='{\n';
    
    for (let k of Object.keys(sceneh)) {
      s+='"'+k+'":'+JSON.stringify(sceneh[k])+',\n';
    }
    
    s+='"points":[\n';
    let first=true;
    for (let p of points) {
      p=p.position;
      s+=(first?' ':',')+JSON.stringify({x:p.x,y:p.y,z:p.z})+'\n';
      first=false;
    }
    s+=']\n';
    
    s+='}';
    return s;
    //...
  }
  
  function setNearestPoint(p) {
    //---
    let op=nearestPoint;
    if (p!==op) {
      if (op) op.material=(op.userData.selected?matPointSel:matPoint0);
      nearestPoint=p;  
      if (p) {
        p.material=matPoint1;
        //xrUtil.log('nearest point '+points.indexOf(p));
      }
    }
    //onsole.log('nearestPoint set '+nearestPoint);
    //...
  }
  
  //...
}
)();
</script>
</body>
</html>
<script>
//fr o,25
//fr o,25,11
//fr o,25,11,46
//fr o,25,11,70
//fr o,25,11,76
//fr o,25,11,78
//fr o,25,16
//fr o,25,19
//fr o,25,21
//fr o,25,23
//fr o,25,25
//fr p,41,254
