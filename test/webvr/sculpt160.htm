<!DOCTYPE html>
<html lang="en">
<head>
<title>sculpt160</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>body { color:#000;background-color:#aaa;margin:0px;overflow:hidden;font-family:Sans-serif; }</style>
<script src="/conet.js"></script>
<script src="/menu.js"></script>
</head>
<body>
<script type="importmap">
{
"imports": {
"three": "/three/r160/build/three.module.js",
"three/addons/": "/three/r160/examples/jsm/"
}
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { MarchingCubes } from 'three/addons/objects/MarchingCubes.js';
import { XrUtil } from '/util/gfx/XrUtil.js';
(function() {
  //---
  let container,camera,scene,renderer,
      controller1,controller2,controls,blob,points=[],
      xrUtil=XrUtil,lsKey='sculpt160_0',
      showPoints=false,lastPointCount=0,pointGroup,pointMaterial,
      colorBlack=new THREE.Color(0,0,0);
      
  init();
  animate();
  
  function init() {
    //---
    container = document.createElement( 'div' );
    document.body.appendChild( container );
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x222222 );
    
    camera=new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 50 );
    camera.position.set( 0, 1.6, 3 );
    scene.add(camera);
    
    controls = new OrbitControls( camera, container );
    controls.target.set( 0, 1.6, 0 );
    controls.update();
    
    const grid=new THREE.GridHelper(4,1,0x111111,0x111111);
    scene.add(grid);
    
    scene.add(new THREE.HemisphereLight(0x888877,0x777788,3));
    
    const light=new THREE.DirectionalLight(0xffffff,3);
    light.position.set(0,6,0);
    scene.add( light );
    
    //
    
    renderer = new THREE.WebGLRenderer( { antialias:true } );
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth,window.innerHeight );
    renderer.xr.enabled=true;
    container.appendChild(renderer.domElement);
    
    //document.body.appendChild( XRButton.createButton( renderer ) );
    
    xrUtil.init({scene:scene,renderer:renderer,camera:camera,room:scene,sculpt:1//,vrPos:vrPos
      });
    xrUtil.initHud();
    
    function selectInButtonGroup(bg,b) {
      //---
      for (let bh of bg) bh.selected=(bh==b);
      //...
    }
    
    function setColor() {
      //---
      console.log(this.color);
      points[0].color=new THREE.Color(this.color);
      if (points[1].color!==undefined) points[1].color=new THREE.Color(this.color);
      xrUtil.log('Brush color is set to '+this.color+'.');
      selectInButtonGroup(bgcolors,this);
      //...
    }
    function setBrush() {
      //---
      if (this.subtract) {
        points[0].subtract=this.subtract;
        points[1].subtract=this.subtract;
        xrUtil.log('Brush subtract is set to '+this.subtract+'.');
        selectInButtonGroup(bgsubtract,this);
      }
      //onsole.log(this.s);
      if (this.strength) {
        points[0].strength=this.strength;
        points[1].strength=this.strength*-2;
        xrUtil.log('Brush strength is set to '+this.strength+'.');
        selectInButtonGroup(bgstrength,this);
      }
      //...
    }
    
    let bgsubtract=[
      {x:0.05,y:0.4,w:0.1,h:0.1,s:'u1',ondown:setBrush,subtract:10,selected:1},
      {x:0.2,y:0.4,w:0.1,h:0.1,s:'u2',ondown:setBrush,subtract:20},
      {x:0.35,y:0.4,w:0.1,h:0.1,s:'u3',ondown:setBrush,subtract:40}
    ];
    
    let bgstrength=[
      {x:0.05,y:0.55,w:0.1,h:0.1,s:'s1',ondown:setBrush,strength:0.01},
      {x:0.2,y:0.55,w:0.1,h:0.1,s:'s2',ondown:setBrush,strength:0.02},
      {x:0.35,y:0.55,w:0.1,h:0.1,s:'s3',ondown:setBrush,strength:0.04,selected:1},
      {x:0.5,y:0.55,w:0.1,h:0.1,s:'s4',ondown:setBrush,strength:0.16},
      {x:0.65,y:0.55,w:0.1,h:0.1,s:'s5',ondown:setBrush,strength:0.6}
    ];
    
    function posButtons(ps) {
      //---
      let x=ps.x;
      for (let b of ps.a) {
        b.x=x;b.y=ps.y;b.z=ps.z;
        b.w=ps.w;b.h=ps.h;
        x+=ps.w+ps.b;
      }
      return ps.a;
      //...
    }
    
    let bgcolors=[].concat(
    posButtons({x:0.05,y:0.7,w:0.1,h:0.1,b:0.05,a:[
      {color:'rgb(250,0,0)',ondown:setColor},
      {color:'rgb(0,250,0)',ondown:setColor},
      {color:'rgb(0,0,250)',ondown:setColor},
    ]}),
    posButtons({x:0.05,y:0.85,w:0.075,h:0.1,b:0.03,a:[
      {color:'rgb(250,250,250)',ondown:setColor,selected:1},
      {color:'rgb(125,125,125)',ondown:setColor},
      {color:'rgb(0,0,0)',ondown:setColor},
      {color:'rgb(250,250,0)',ondown:setColor}
    ]}));
    
    xrUtil.hud.buttons=[
    {s:'Save',x:0.5,y:0.7,w:0.45,h:0.25,ondown:function() {
      //---
      const data=serialize();
      localStorage[lsKey]=data;
      xrUtil.log('Saved to localStorage '+data.length+' bytes.');
      //...
    }
    },
    
    {x:0.8,y:0.55,w:0.15,h:0.1,s:'P',ondown:function() {
      //---
      showPoints=!showPoints;
      if (showPoints) {
        this.s='NP';
        xrUtil.log('Current mode: diminish points.');
        lastPointCount=0;
      } else {
        this.s='P';
        if (pointGroup) { scene.remove(pointGroup);pointGroup=undefined; }
        xrUtil.log('Current mode: diminish sculpt w/ points.');
      }
      
      //...
    }
    },
    
    {x:0.5,y:0.4,w:0.45,h:0.1,s:'DimColor',ondown:function() {
      //---
      if (!points[1].color) {
        points[1].color=points[0].color;
        this.s='DimNoColor';
        xrUtil.log('Diminish sculpt with colors.');
      } else {
        points[1].color=undefined;
        this.s='DimColor';
        xrUtil.log('Diminish sculpt without colors.');
      }
      //...
    }
    }
    
    ].concat(bgsubtract,bgstrength,bgcolors);
    const version='v.0.121 ';//FOLDORUPDATEVERSION
    xrUtil.log('sculpt '+version);
    
    controller1=xrUtil.ctrl0;
    controller2=xrUtil.ctrl1;
    controller1.userData.id=0;
    controller2.userData.id=1;
    
    //
    
    const pivot = new THREE.Mesh( new THREE.IcosahedronGeometry( 0.01, 3 ) );
    pivot.name = 'pivot';
    pivot.position.z = - 0.05;
    
    const group = new THREE.Group();
    group.add( pivot );
    
    controller1.add( group.clone() );
    controller2.add( group.clone() );
    //
    window.addEventListener( 'resize', onWindowResize );
    
    //--- initBlob
    
    /*
    const path = 'textures/cube/SwedishRoyalCastle/';
    const format = '.jpg';
    const urls = [
    path + 'px' + format, path + 'nx' + format,
    path + 'py' + format, path + 'ny' + format,
    path + 'pz' + format, path + 'nz' + format
    ];
    
    const reflectionCube = new THREE.CubeTextureLoader().load( urls );
    */
    
    const material = new THREE.MeshStandardMaterial( {
      color: 0xffffff,
      // envMap: reflectionCube,
      roughness: 0.9,
      metalness: 0.0,
      transparent: true,
      vertexColors: true
    });
    
    
    blob=new MarchingCubes(64,material,false,true,500000);
    blob.position.y = 1;
    scene.add( blob );
    
    points=[
      {position:new THREE.Vector3(),strength:0.04,subtract:10,color:new THREE.Color(bgcolors[3].color)},
      {position:new THREE.Vector3(),strength:-0.08,subtract:10,color:undefined}//new THREE.Color(bgcolors[3].color)}
    ];
    
    let d=localStorage[lsKey];
    if (d!==undefined)
      load(d);
    else for (let i=0;i<10;i++) {
      points.push({position:new THREE.Vector3(0.5+i*0.03,0.5,0.5),strength:0.04,subtract:10,color:new THREE.Color(0.1,0.9,0.1)});
    }
    
    //---menu
    
    xrUtil.menuXr.ms+=' '+version;
    Menu.init([{s:'&#9776;',noTri:true,fs:1.4,pw:0.05,sub:[
      Menu.mFullscreen,  
    {s:'Json',ms:'import/export',doctrl:'Json data',mcfs:0.07,ta:true,jsonCheck:1,wrap:0,tacols:30,tarows:20
      ,setfunc:load,valuef:serialize}
    ,{s:'Clear blobs',actionf:function() {
      //---
      //alert(23);
      points.length=2;
      //...
    }
    }
    
      ]} 
     ,xrUtil.menuXr  
      ]
      ,{listen:1});
    
    
    //pointMaterial=new THREE.MeshPhongMaterial({color:0x77dd77,flatShading:true,transparent:true,opacity:0.7});
    pointMaterial=new THREE.MeshPhongMaterial({flatShading:true,color:0x66aa66,depthTest:false,transparent:true,opacity:0.7});
    
    //...
  }
  function onWindowResize() {
    //---
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
    //...
  }
  //
  function animate() {
    renderer.setAnimationLoop(render);
  }
  function transformPoint( vector ) {
    //---
    vector.x=(vector.x+1.0)/2.0;
    vector.y=(vector.y/2.0);
    vector.z=(vector.z+1.0)/2.0;
    //...
  }
  function handleController(controller) {
    //---
    const pivot=controller.getObjectByName('pivot');
    if (pivot) {
      const id=controller.userData.id;
      const matrix=pivot.matrixWorld;
      points[id].position.setFromMatrixPosition(matrix);
      transformPoint(points[id].position);
    
      if (controller.userData.isSelecting&&!xrUtil.hud.cursor.vis) {
        const point=points[id];
        const strength=point.strength/2;
        const vector=new THREE.Vector3().setFromMatrixPosition(matrix);
        transformPoint(vector);
        if ((id==1)&&showPoints) {
          let md=0.1,mi=-1;
          for (let i=2;i<points.length;i++) {
            let p=points[i].position,dx=vector.x-p.x,dy=vector.y-p.y,dz=vector.z-p.z,
                d=dx*dx+dy*dy+dz*dz;
            if (d>=md) continue;
            md=d;mi=i;
          }
          if (mi!=-1) points.splice(mi,1);
        } else
          points.push({position:vector,strength:strength,subtract:point.subtract,color:((id==1)&&(!point.color))?colorBlack:point.color});
      }
    }
    //...
  }
  function updateBlob() {
    //---
    blob.reset();
    for (let i=0;i<points.length;i++) {
      const point=points[i];
      const position=point.position;
      blob.addBall(position.x,position.y,position.z,point.strength,point.subtract,point.color);
    }
    blob.update();
    if (0&&showPoints&&(points.length!=lastPointCount)) {
      //onsole.log('render points now '+points.length+' '+lastPointCount);
      lastPointCount=points.length;
      if (pointGroup) scene.remove(pointGroup);
      pointGroup=new THREE.Group();
      for (let i=0;i<points.length;i++) {
        let p=points[i],pos=p.position,w=p.strength,
            g=new THREE.BoxGeometry(Math.abs(w),w<0?0.001:w,Math.abs(w)),
            mesh=new THREE.Mesh(g,pointMaterial);
        //g.computeBoundingSphere();
        mesh.position.set(pos.x*2-1,pos.y*2,pos.z*2-1);
        //mesh.updateMatrix();
        //mesh.matrixAutoUpdate=false;
        //mesh.castShadow=true;
        //mesh.receiveShadow=true;
        pointGroup.add(mesh);
        //scene.add(mesh);
      }
      scene.add(pointGroup);
      //scene.remove(blob);
    }
    //...
  }
  function render() {
    //---
    handleController(controller1);
    handleController(controller2);
    updateBlob();
    xrUtil.renderHud();
    renderer.render(scene,camera);
    //...
  }
  function load(v,initLoad) {
    //---
    var d=JSON.parse(v);
    points.length=2;
    points=points.concat(d.points);
    //...
  }
  function serialize() {
    //---
    let s='{"points":[\n';
    for (let i=2;i<points.length;i++)
      s+=JSON.stringify(points[i])+((i<points.length-1)?',':'')+'\n';
    s+=']}\n';
    return s;
    //...
  }
  //...
}
)();
</script>
</body>
</html>
<script>
//fr o,24
//fr o,24,10
//fr o,24,10,38
//fr o,24,10,40
//fr o,24,10,41
//fr o,24,10,79
//fr o,24,10,152
//fr o,24,15
//fr o,24,16
//fr o,24,17
//fr o,24,18
//fr p,7,289
